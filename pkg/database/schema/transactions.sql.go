// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTransactions = `-- name: CreateTransactions :one
INSERT INTO transactions (order_id, merchant_id, payment_method, amount, change_amount, payment_status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
`

type CreateTransactionsParams struct {
	OrderID       int32         `json:"order_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
}

func (q *Queries) CreateTransactions(ctx context.Context, arg CreateTransactionsParams) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransactions,
		arg.OrderID,
		arg.MerchantID,
		arg.PaymentMethod,
		arg.Amount,
		arg.ChangeAmount,
		arg.PaymentStatus,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentTransactions = `-- name: DeleteAllPermanentTransactions :exec
DELETE FROM transactions
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Transaction Permanently
func (q *Queries) DeleteAllPermanentTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentTransactions)
	return err
}

const deleteTransactionPermanently = `-- name: DeleteTransactionPermanently :exec
DELETE FROM transactions WHERE transaction_id = $1 AND deleted_at IS NOT NULL
`

// Delete Transaction Permanently
func (q *Queries) DeleteTransactionPermanently(ctx context.Context, transactionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionPermanently, transactionID)
	return err
}

const getMonthlyAmountTransactionFailed = `-- name: GetMonthlyAmountTransactionFailed :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        EXTRACT(MONTH FROM t.created_at)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'failed'
        AND (
            (t.created_at >= $1::timestamp AND t.created_at <= $2::timestamp)
            OR (t.created_at >= $3::timestamp AND t.created_at <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        EXTRACT(MONTH FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyAmountTransactionFailedParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthlyAmountTransactionFailedRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmountTransactionFailed(ctx context.Context, arg GetMonthlyAmountTransactionFailedParams) ([]*GetMonthlyAmountTransactionFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountTransactionFailed,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountTransactionFailedRow
	for rows.Next() {
		var i GetMonthlyAmountTransactionFailedRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountTransactionFailedByMerchant = `-- name: GetMonthlyAmountTransactionFailedByMerchant :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        EXTRACT(MONTH FROM t.created_at)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'failed'
        AND t.merchant_id = $5
        AND (
            (t.created_at >= $1::timestamp AND t.created_at <= $2::timestamp)
            OR (t.created_at >= $3::timestamp AND t.created_at <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        EXTRACT(MONTH FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyAmountTransactionFailedByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	Column2    time.Time `json:"column_2"`
	Column3    time.Time `json:"column_3"`
	Column4    time.Time `json:"column_4"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyAmountTransactionFailedByMerchantRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmountTransactionFailedByMerchant(ctx context.Context, arg GetMonthlyAmountTransactionFailedByMerchantParams) ([]*GetMonthlyAmountTransactionFailedByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountTransactionFailedByMerchant,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.MerchantID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountTransactionFailedByMerchantRow
	for rows.Next() {
		var i GetMonthlyAmountTransactionFailedByMerchantRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountTransactionSuccess = `-- name: GetMonthlyAmountTransactionSuccess :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        EXTRACT(MONTH FROM t.created_at)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND (
            (t.created_at >= $1::timestamp AND t.created_at <= $2::timestamp)
            OR (t.created_at >= $3::timestamp AND t.created_at <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        EXTRACT(MONTH FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyAmountTransactionSuccessParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthlyAmountTransactionSuccessRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmountTransactionSuccess(ctx context.Context, arg GetMonthlyAmountTransactionSuccessParams) ([]*GetMonthlyAmountTransactionSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountTransactionSuccess,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountTransactionSuccessRow
	for rows.Next() {
		var i GetMonthlyAmountTransactionSuccessRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountTransactionSuccessByMerchant = `-- name: GetMonthlyAmountTransactionSuccessByMerchant :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        EXTRACT(MONTH FROM t.created_at)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND t.merchant_id = $5
        AND (
            (t.created_at >= $1::timestamp AND t.created_at <= $2::timestamp)
            OR (t.created_at >= $3::timestamp AND t.created_at <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        EXTRACT(MONTH FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyAmountTransactionSuccessByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	Column2    time.Time `json:"column_2"`
	Column3    time.Time `json:"column_3"`
	Column4    time.Time `json:"column_4"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyAmountTransactionSuccessByMerchantRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmountTransactionSuccessByMerchant(ctx context.Context, arg GetMonthlyAmountTransactionSuccessByMerchantParams) ([]*GetMonthlyAmountTransactionSuccessByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountTransactionSuccessByMerchant,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.MerchantID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountTransactionSuccessByMerchantRow
	for rows.Next() {
		var i GetMonthlyAmountTransactionSuccessByMerchantRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransactionMethods = `-- name: GetMonthlyTransactionMethods :many
WITH date_range AS (
    SELECT 
        date_trunc('month', $1::timestamp) AS start_date,
        date_trunc('month', $1::timestamp) + interval '1 year' - interval '1 day' AS end_date
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
),
monthly_transactions AS (
    SELECT
        date_trunc('month', t.created_at) AS activity_month,
        t.payment_method,
        COUNT(t.transaction_id) AS total_transactions,
        SUM(t.amount)::NUMERIC AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND t.created_at BETWEEN (SELECT start_date FROM date_range) 
                             AND (SELECT end_date FROM date_range)
    GROUP BY
        activity_month, t.payment_method
)
SELECT
    TO_CHAR(mt.activity_month, 'Mon') AS month,
    mt.payment_method,
    mt.total_transactions,
    mt.total_amount
FROM
    monthly_transactions mt
ORDER BY
    mt.activity_month,
    mt.payment_method
`

type GetMonthlyTransactionMethodsRow struct {
	Month             string  `json:"month"`
	PaymentMethod     string  `json:"payment_method"`
	TotalTransactions int64   `json:"total_transactions"`
	TotalAmount       float64 `json:"total_amount"`
}

func (q *Queries) GetMonthlyTransactionMethods(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTransactionMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransactionMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransactionMethodsRow
	for rows.Next() {
		var i GetMonthlyTransactionMethodsRow
		if err := rows.Scan(
			&i.Month,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransactionMethodsByMerchant = `-- name: GetMonthlyTransactionMethodsByMerchant :many
WITH date_range AS (
    SELECT 
        date_trunc('month', $1::timestamp) AS start_date,
        date_trunc('month', $1::timestamp) + interval '1 year' - interval '1 day' AS end_date
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
),
monthly_transactions AS (
    SELECT
        date_trunc('month', t.created_at) AS activity_month,
        t.payment_method,
        COUNT(t.transaction_id) AS total_transactions,
        SUM(t.amount)::NUMERIC AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND t.created_at BETWEEN (SELECT start_date FROM date_range) 
                             AND (SELECT end_date FROM date_range)
        AND t.merchant_id = $2
    GROUP BY
        activity_month, t.payment_method
)
SELECT
    TO_CHAR(mt.activity_month, 'Mon') AS month,
    mt.payment_method,
    mt.total_transactions,
    mt.total_amount
FROM
    monthly_transactions mt
ORDER BY
    mt.activity_month,
    mt.payment_method
`

type GetMonthlyTransactionMethodsByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyTransactionMethodsByMerchantRow struct {
	Month             string  `json:"month"`
	PaymentMethod     string  `json:"payment_method"`
	TotalTransactions int64   `json:"total_transactions"`
	TotalAmount       float64 `json:"total_amount"`
}

func (q *Queries) GetMonthlyTransactionMethodsByMerchant(ctx context.Context, arg GetMonthlyTransactionMethodsByMerchantParams) ([]*GetMonthlyTransactionMethodsByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransactionMethodsByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransactionMethodsByMerchantRow
	for rows.Next() {
		var i GetMonthlyTransactionMethodsByMerchantRow
		if err := rows.Scan(
			&i.Month,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
FROM transactions
WHERE transaction_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetTransactionByID(ctx context.Context, transactionID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransactionByMerchant = `-- name: GetTransactionByMerchant :many
SELECT
    transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM transactions
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR payment_method ILIKE '%' || $1 || '%' OR payment_status ILIKE '%' || $1 || '%')
  AND ($2::INT IS NULL OR merchant_id = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetTransactionByMerchantParams struct {
	Column1 string `json:"column_1"`
	Column2 int32  `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransactionByMerchantRow struct {
	TransactionID int32         `json:"transaction_id"`
	OrderID       int32         `json:"order_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
	CreatedAt     sql.NullTime  `json:"created_at"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	DeletedAt     sql.NullTime  `json:"deleted_at"`
	TotalCount    int64         `json:"total_count"`
}

func (q *Queries) GetTransactionByMerchant(ctx context.Context, arg GetTransactionByMerchantParams) ([]*GetTransactionByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByMerchant,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionByMerchantRow
	for rows.Next() {
		var i GetTransactionByMerchantRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.OrderID,
			&i.MerchantID,
			&i.PaymentMethod,
			&i.Amount,
			&i.ChangeAmount,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByOrderID = `-- name: GetTransactionByOrderID :one
SELECT transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
FROM transactions
WHERE order_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetTransactionByOrderID(ctx context.Context, orderID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByOrderID, orderID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT
    transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM transactions
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR payment_method ILIKE '%' || $1 || '%' OR payment_status ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransactionsRow struct {
	TransactionID int32         `json:"transaction_id"`
	OrderID       int32         `json:"order_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
	CreatedAt     sql.NullTime  `json:"created_at"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	DeletedAt     sql.NullTime  `json:"deleted_at"`
	TotalCount    int64         `json:"total_count"`
}

func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]*GetTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsRow
	for rows.Next() {
		var i GetTransactionsRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.OrderID,
			&i.MerchantID,
			&i.PaymentMethod,
			&i.Amount,
			&i.ChangeAmount,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsActive = `-- name: GetTransactionsActive :many
SELECT
    transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM transactions
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR payment_method ILIKE '%' || $1 || '%' OR payment_status ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransactionsActiveRow struct {
	TransactionID int32         `json:"transaction_id"`
	OrderID       int32         `json:"order_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
	CreatedAt     sql.NullTime  `json:"created_at"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	DeletedAt     sql.NullTime  `json:"deleted_at"`
	TotalCount    int64         `json:"total_count"`
}

// Get Active Transactions with Pagination and Total Count
func (q *Queries) GetTransactionsActive(ctx context.Context, arg GetTransactionsActiveParams) ([]*GetTransactionsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsActiveRow
	for rows.Next() {
		var i GetTransactionsActiveRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.OrderID,
			&i.MerchantID,
			&i.PaymentMethod,
			&i.Amount,
			&i.ChangeAmount,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsTrashed = `-- name: GetTransactionsTrashed :many
SELECT
    transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM transactions
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL OR payment_method ILIKE '%' || $1 || '%' OR payment_status ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransactionsTrashedRow struct {
	TransactionID int32         `json:"transaction_id"`
	OrderID       int32         `json:"order_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
	CreatedAt     sql.NullTime  `json:"created_at"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	DeletedAt     sql.NullTime  `json:"deleted_at"`
	TotalCount    int64         `json:"total_count"`
}

// Get Trashed Transactions with Pagination and Total Count
func (q *Queries) GetTransactionsTrashed(ctx context.Context, arg GetTransactionsTrashedParams) ([]*GetTransactionsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsTrashedRow
	for rows.Next() {
		var i GetTransactionsTrashedRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.OrderID,
			&i.MerchantID,
			&i.PaymentMethod,
			&i.Amount,
			&i.ChangeAmount,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountTransactionFailed = `-- name: GetYearlyAmountTransactionFailed :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'failed'
        AND (
            EXTRACT(YEAR FROM t.created_at) = $1::integer
            OR EXTRACT(YEAR FROM t.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyAmountTransactionFailedRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmountTransactionFailed(ctx context.Context, dollar_1 int32) ([]*GetYearlyAmountTransactionFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountTransactionFailed, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountTransactionFailedRow
	for rows.Next() {
		var i GetYearlyAmountTransactionFailedRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountTransactionFailedByMerchant = `-- name: GetYearlyAmountTransactionFailedByMerchant :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'failed'
        AND t.merchant_id = $2
        AND (
            EXTRACT(YEAR FROM t.created_at) = $1::integer
            OR EXTRACT(YEAR FROM t.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyAmountTransactionFailedByMerchantParams struct {
	Column1    int32 `json:"column_1"`
	MerchantID int32 `json:"merchant_id"`
}

type GetYearlyAmountTransactionFailedByMerchantRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmountTransactionFailedByMerchant(ctx context.Context, arg GetYearlyAmountTransactionFailedByMerchantParams) ([]*GetYearlyAmountTransactionFailedByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountTransactionFailedByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountTransactionFailedByMerchantRow
	for rows.Next() {
		var i GetYearlyAmountTransactionFailedByMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountTransactionSuccess = `-- name: GetYearlyAmountTransactionSuccess :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND (
            EXTRACT(YEAR FROM t.created_at) = $1::integer
            OR EXTRACT(YEAR FROM t.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyAmountTransactionSuccessRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmountTransactionSuccess(ctx context.Context, dollar_1 int32) ([]*GetYearlyAmountTransactionSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountTransactionSuccess, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountTransactionSuccessRow
	for rows.Next() {
		var i GetYearlyAmountTransactionSuccessRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountTransactionSuccessByMerchant = `-- name: GetYearlyAmountTransactionSuccessByMerchant :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND t.merchant_id = $2
        AND (
            EXTRACT(YEAR FROM t.created_at) = $1::integer
            OR EXTRACT(YEAR FROM t.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.created_at)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyAmountTransactionSuccessByMerchantParams struct {
	Column1    int32 `json:"column_1"`
	MerchantID int32 `json:"merchant_id"`
}

type GetYearlyAmountTransactionSuccessByMerchantRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmountTransactionSuccessByMerchant(ctx context.Context, arg GetYearlyAmountTransactionSuccessByMerchantParams) ([]*GetYearlyAmountTransactionSuccessByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountTransactionSuccessByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountTransactionSuccessByMerchantRow
	for rows.Next() {
		var i GetYearlyAmountTransactionSuccessByMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransactionMethods = `-- name: GetYearlyTransactionMethods :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::text AS year,
        t.payment_method,
        COUNT(t.transaction_id) AS total_transactions,
        SUM(t.amount)::NUMERIC AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND EXTRACT(YEAR FROM t.created_at) BETWEEN (EXTRACT(YEAR FROM $1::timestamp) - 4) AND EXTRACT(YEAR FROM $1::timestamp)
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        t.payment_method
)
SELECT
    year,
    payment_method,
    total_transactions,
    total_amount
FROM
    last_five_years
ORDER BY
    year,
    payment_method
`

type GetYearlyTransactionMethodsRow struct {
	Year              string  `json:"year"`
	PaymentMethod     string  `json:"payment_method"`
	TotalTransactions int64   `json:"total_transactions"`
	TotalAmount       float64 `json:"total_amount"`
}

func (q *Queries) GetYearlyTransactionMethods(ctx context.Context, dollar_1 time.Time) ([]*GetYearlyTransactionMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransactionMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransactionMethodsRow
	for rows.Next() {
		var i GetYearlyTransactionMethodsRow
		if err := rows.Scan(
			&i.Year,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransactionMethodsByMerchant = `-- name: GetYearlyTransactionMethodsByMerchant :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.created_at)::text AS year,
        t.payment_method,
        COUNT(t.transaction_id) AS total_transactions,
        SUM(t.amount)::NUMERIC AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.payment_status = 'success'
        AND EXTRACT(YEAR FROM t.created_at) BETWEEN (EXTRACT(YEAR FROM $1::timestamp) - 4) AND EXTRACT(YEAR FROM $1::timestamp)
        AND t.merchant_id = $2
    GROUP BY
        EXTRACT(YEAR FROM t.created_at),
        t.payment_method
)
SELECT
    year,
    payment_method,
    total_transactions,
    total_amount
FROM
    last_five_years
ORDER BY
    year,
    payment_method
`

type GetYearlyTransactionMethodsByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetYearlyTransactionMethodsByMerchantRow struct {
	Year              string  `json:"year"`
	PaymentMethod     string  `json:"payment_method"`
	TotalTransactions int64   `json:"total_transactions"`
	TotalAmount       float64 `json:"total_amount"`
}

func (q *Queries) GetYearlyTransactionMethodsByMerchant(ctx context.Context, arg GetYearlyTransactionMethodsByMerchantParams) ([]*GetYearlyTransactionMethodsByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransactionMethodsByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransactionMethodsByMerchantRow
	for rows.Next() {
		var i GetYearlyTransactionMethodsByMerchantRow
		if err := rows.Scan(
			&i.Year,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllTransactions = `-- name: RestoreAllTransactions :exec
UPDATE transactions
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Transaction
func (q *Queries) RestoreAllTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllTransactions)
	return err
}

const restoreTransaction = `-- name: RestoreTransaction :one
UPDATE transactions
SET
    deleted_at = NULL
WHERE
    transaction_id = $1
    AND deleted_at IS NOT NULL
  RETURNING transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
`

// Restore Trashed Transaction
func (q *Queries) RestoreTransaction(ctx context.Context, transactionID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, restoreTransaction, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashTransaction = `-- name: TrashTransaction :one
UPDATE transactions
SET
    deleted_at = current_timestamp
WHERE
    transaction_id = $1
    AND deleted_at IS NULL
    RETURNING transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
`

// Trash Transaction
func (q *Queries) TrashTransaction(ctx context.Context, transactionID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, trashTransaction, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET merchant_id = $2,
    payment_method = $3,
    amount = $4,
    change_amount = $5,
    payment_status = $6,
    order_id = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE transaction_id = $1
  AND deleted_at IS NULL
RETURNING transaction_id, order_id, merchant_id, payment_method, amount, change_amount, payment_status, created_at, updated_at, deleted_at
`

type UpdateTransactionParams struct {
	TransactionID int32         `json:"transaction_id"`
	MerchantID    int32         `json:"merchant_id"`
	PaymentMethod string        `json:"payment_method"`
	Amount        int32         `json:"amount"`
	ChangeAmount  sql.NullInt32 `json:"change_amount"`
	PaymentStatus string        `json:"payment_status"`
	OrderID       int32         `json:"order_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.TransactionID,
		arg.MerchantID,
		arg.PaymentMethod,
		arg.Amount,
		arg.ChangeAmount,
		arg.PaymentStatus,
		arg.OrderID,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.OrderID,
		&i.MerchantID,
		&i.PaymentMethod,
		&i.Amount,
		&i.ChangeAmount,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
