// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cachiers.sql

package db

import (
	"context"
	"database/sql"
)

const createCashier = `-- name: CreateCashier :one
INSERT INTO cashiers (merchant_id, user_id, name)
VALUES ($1, $2, $3) RETURNING cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at
`

type CreateCashierParams struct {
	MerchantID int32  `json:"merchant_id"`
	UserID     int32  `json:"user_id"`
	Name       string `json:"name"`
}

func (q *Queries) CreateCashier(ctx context.Context, arg CreateCashierParams) (*Cashier, error) {
	row := q.db.QueryRowContext(ctx, createCashier, arg.MerchantID, arg.UserID, arg.Name)
	var i Cashier
	err := row.Scan(
		&i.CashierID,
		&i.MerchantID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentCashiers = `-- name: DeleteAllPermanentCashiers :exec
DELETE FROM cashiers
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Cashier Permanently
func (q *Queries) DeleteAllPermanentCashiers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentCashiers)
	return err
}

const deleteCashierPermanently = `-- name: DeleteCashierPermanently :exec
DELETE FROM cashiers WHERE cashier_id = $1 AND deleted_at IS NOT NULL
`

// Delete Cashier Permanently
func (q *Queries) DeleteCashierPermanently(ctx context.Context, cashierID int32) error {
	_, err := q.db.ExecContext(ctx, deleteCashierPermanently, cashierID)
	return err
}

const getCashierByID = `-- name: GetCashierByID :one
SELECT cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at
FROM cashiers
WHERE cashier_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetCashierByID(ctx context.Context, cashierID int32) (*Cashier, error) {
	row := q.db.QueryRowContext(ctx, getCashierByID, cashierID)
	var i Cashier
	err := row.Scan(
		&i.CashierID,
		&i.MerchantID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getCashiers = `-- name: GetCashiers :many
SELECT
    cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cashiers
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCashiersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetCashiersRow struct {
	CashierID  int32        `json:"cashier_id"`
	MerchantID int32        `json:"merchant_id"`
	UserID     int32        `json:"user_id"`
	Name       string       `json:"name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

func (q *Queries) GetCashiers(ctx context.Context, arg GetCashiersParams) ([]*GetCashiersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashiers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCashiersRow
	for rows.Next() {
		var i GetCashiersRow
		if err := rows.Scan(
			&i.CashierID,
			&i.MerchantID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashiersActive = `-- name: GetCashiersActive :many
SELECT
    cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cashiers
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCashiersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetCashiersActiveRow struct {
	CashierID  int32        `json:"cashier_id"`
	MerchantID int32        `json:"merchant_id"`
	UserID     int32        `json:"user_id"`
	Name       string       `json:"name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

func (q *Queries) GetCashiersActive(ctx context.Context, arg GetCashiersActiveParams) ([]*GetCashiersActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashiersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCashiersActiveRow
	for rows.Next() {
		var i GetCashiersActiveRow
		if err := rows.Scan(
			&i.CashierID,
			&i.MerchantID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashiersByMerchant = `-- name: GetCashiersByMerchant :many
SELECT
    cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cashiers
WHERE merchant_id = $1
  AND deleted_at IS NULL
  AND ($2::TEXT IS NULL OR name ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetCashiersByMerchantParams struct {
	MerchantID int32  `json:"merchant_id"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetCashiersByMerchantRow struct {
	CashierID  int32        `json:"cashier_id"`
	MerchantID int32        `json:"merchant_id"`
	UserID     int32        `json:"user_id"`
	Name       string       `json:"name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

func (q *Queries) GetCashiersByMerchant(ctx context.Context, arg GetCashiersByMerchantParams) ([]*GetCashiersByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashiersByMerchant,
		arg.MerchantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCashiersByMerchantRow
	for rows.Next() {
		var i GetCashiersByMerchantRow
		if err := rows.Scan(
			&i.CashierID,
			&i.MerchantID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashiersTrashed = `-- name: GetCashiersTrashed :many
SELECT
    cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cashiers
WHERE deleted_at IS NOT NULL
  AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCashiersTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetCashiersTrashedRow struct {
	CashierID  int32        `json:"cashier_id"`
	MerchantID int32        `json:"merchant_id"`
	UserID     int32        `json:"user_id"`
	Name       string       `json:"name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

func (q *Queries) GetCashiersTrashed(ctx context.Context, arg GetCashiersTrashedParams) ([]*GetCashiersTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashiersTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCashiersTrashedRow
	for rows.Next() {
		var i GetCashiersTrashedRow
		if err := rows.Scan(
			&i.CashierID,
			&i.MerchantID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllCashiers = `-- name: RestoreAllCashiers :exec
UPDATE cashiers
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Cashier
func (q *Queries) RestoreAllCashiers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllCashiers)
	return err
}

const restoreCashier = `-- name: RestoreCashier :one
UPDATE cashiers
SET
    deleted_at = NULL
WHERE
    cashier_id = $1
    AND deleted_at IS NOT NULL
  RETURNING cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at
`

// Restore Trashed Cashier
func (q *Queries) RestoreCashier(ctx context.Context, cashierID int32) (*Cashier, error) {
	row := q.db.QueryRowContext(ctx, restoreCashier, cashierID)
	var i Cashier
	err := row.Scan(
		&i.CashierID,
		&i.MerchantID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashCashier = `-- name: TrashCashier :one
UPDATE cashiers
SET
    deleted_at = current_timestamp
WHERE
    cashier_id = $1
    AND deleted_at IS NULL
    RETURNING cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at
`

// Trash Cashier
func (q *Queries) TrashCashier(ctx context.Context, cashierID int32) (*Cashier, error) {
	row := q.db.QueryRowContext(ctx, trashCashier, cashierID)
	var i Cashier
	err := row.Scan(
		&i.CashierID,
		&i.MerchantID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateCashier = `-- name: UpdateCashier :one
UPDATE cashiers
SET name = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE cashier_id = $1
  AND deleted_at IS NULL
  RETURNING cashier_id, merchant_id, user_id, name, created_at, updated_at, deleted_at
`

type UpdateCashierParams struct {
	CashierID int32  `json:"cashier_id"`
	Name      string `json:"name"`
}

func (q *Queries) UpdateCashier(ctx context.Context, arg UpdateCashierParams) (*Cashier, error) {
	row := q.db.QueryRowContext(ctx, updateCashier, arg.CashierID, arg.Name)
	var i Cashier
	err := row.Scan(
		&i.CashierID,
		&i.MerchantID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
