// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package db

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.MerchantID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.CountInStock,
		arg.Brand,
		arg.Weight,
		arg.Rating,
		arg.SlugProduct,
		arg.ImageProduct,
		arg.Barcode,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentProducts = `-- name: DeleteAllPermanentProducts :exec
DELETE FROM products
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Product Permanently
func (q *Queries) DeleteAllPermanentProducts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentProducts)
	return err
}

const deleteProductPermanently = `-- name: DeleteProductPermanently :exec
DELETE FROM products WHERE product_id = $1 AND deleted_at IS NOT NULL
`

// Delete Product Permanently
func (q *Queries) DeleteProductPermanently(ctx context.Context, productID int32) error {
	_, err := q.db.ExecContext(ctx, deleteProductPermanently, productID)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
FROM products
WHERE product_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetProductByID(ctx context.Context, productID int32) (*Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
    product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM products
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL 
       OR p.name ILIKE '%' || $1 || '%'
       OR p.description ILIKE '%' || $1 || '%'
       OR p.brand ILIKE '%' || $1 || '%'
       OR p.slug_product ILIKE '%' || $1 || '%'
       OR p.barcode ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetProductsRow struct {
	ProductID    int32           `json:"product_id"`
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	DeletedAt    sql.NullTime    `json:"deleted_at"`
	TotalCount   int64           `json:"total_count"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]*GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CountInStock,
			&i.Brand,
			&i.Weight,
			&i.Rating,
			&i.SlugProduct,
			&i.ImageProduct,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsActive = `-- name: GetProductsActive :many
SELECT
    product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM products
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL 
       OR p.name ILIKE '%' || $1 || '%'
       OR p.description ILIKE '%' || $1 || '%'
       OR p.brand ILIKE '%' || $1 || '%'
       OR p.slug_product ILIKE '%' || $1 || '%'
       OR p.barcode ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetProductsActiveRow struct {
	ProductID    int32           `json:"product_id"`
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	DeletedAt    sql.NullTime    `json:"deleted_at"`
	TotalCount   int64           `json:"total_count"`
}

// Get Active Products with Pagination and Total Count
func (q *Queries) GetProductsActive(ctx context.Context, arg GetProductsActiveParams) ([]*GetProductsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductsActiveRow
	for rows.Next() {
		var i GetProductsActiveRow
		if err := rows.Scan(
			&i.ProductID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CountInStock,
			&i.Brand,
			&i.Weight,
			&i.Rating,
			&i.SlugProduct,
			&i.ImageProduct,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategoryName = `-- name: GetProductsByCategoryName :many
SELECT
    p.product_id, p.merchant_id, p.category_id, p.name, p.description, p.price, p.count_in_stock, p.brand, p.weight, p.rating, p.slug_product, p.image_product, p.barcode, p.created_at, p.updated_at, p.deleted_at,
    COUNT(*) OVER() AS total_count
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE c.deleted_at IS NULL
  AND c.name = $1 
  AND ($2::TEXT IS NULL 
       OR p.name ILIKE '%' || $2 || '%'
       OR p.description ILIKE '%' || $2 || '%'
       OR p.brand ILIKE '%' || $2 || '%'
       OR p.slug_product ILIKE '%' || $2 || '%'
       OR p.barcode ILIKE '%' || $2 || '%')
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetProductsByCategoryNameParams struct {
	Name    string `json:"name"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetProductsByCategoryNameRow struct {
	ProductID    int32           `json:"product_id"`
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	DeletedAt    sql.NullTime    `json:"deleted_at"`
	TotalCount   int64           `json:"total_count"`
}

// Get Products by Category Name with Filters
func (q *Queries) GetProductsByCategoryName(ctx context.Context, arg GetProductsByCategoryNameParams) ([]*GetProductsByCategoryNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategoryName,
		arg.Name,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductsByCategoryNameRow
	for rows.Next() {
		var i GetProductsByCategoryNameRow
		if err := rows.Scan(
			&i.ProductID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CountInStock,
			&i.Brand,
			&i.Weight,
			&i.Rating,
			&i.SlugProduct,
			&i.ImageProduct,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByMerchant = `-- name: GetProductsByMerchant :many
SELECT
    product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM products
WHERE merchant_id = $1
AND deleted_at IS NULL
AND ($2::TEXT IS NULL 
       OR p.name ILIKE '%' || $2 || '%'
       OR p.description ILIKE '%' || $2 || '%'
       OR p.brand ILIKE '%' || $2 || '%'
       OR p.slug_product ILIKE '%' || $2 || '%'
       OR p.barcode ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetProductsByMerchantParams struct {
	MerchantID int32  `json:"merchant_id"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetProductsByMerchantRow struct {
	ProductID    int32           `json:"product_id"`
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	DeletedAt    sql.NullTime    `json:"deleted_at"`
	TotalCount   int64           `json:"total_count"`
}

func (q *Queries) GetProductsByMerchant(ctx context.Context, arg GetProductsByMerchantParams) ([]*GetProductsByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByMerchant,
		arg.MerchantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductsByMerchantRow
	for rows.Next() {
		var i GetProductsByMerchantRow
		if err := rows.Scan(
			&i.ProductID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CountInStock,
			&i.Brand,
			&i.Weight,
			&i.Rating,
			&i.SlugProduct,
			&i.ImageProduct,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsTrashed = `-- name: GetProductsTrashed :many
SELECT
    product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM products
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL 
       OR p.name ILIKE '%' || $1 || '%'
       OR p.description ILIKE '%' || $1 || '%'
       OR p.brand ILIKE '%' || $1 || '%'
       OR p.slug_product ILIKE '%' || $1 || '%'
       OR p.barcode ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetProductsTrashedRow struct {
	ProductID    int32           `json:"product_id"`
	MerchantID   int32           `json:"merchant_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	DeletedAt    sql.NullTime    `json:"deleted_at"`
	TotalCount   int64           `json:"total_count"`
}

// Get Trashed Products with Pagination and Total Count
func (q *Queries) GetProductsTrashed(ctx context.Context, arg GetProductsTrashedParams) ([]*GetProductsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductsTrashedRow
	for rows.Next() {
		var i GetProductsTrashedRow
		if err := rows.Scan(
			&i.ProductID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CountInStock,
			&i.Brand,
			&i.Weight,
			&i.Rating,
			&i.SlugProduct,
			&i.ImageProduct,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllProducts = `-- name: RestoreAllProducts :exec
UPDATE products
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Product
func (q *Queries) RestoreAllProducts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllProducts)
	return err
}

const restoreProduct = `-- name: RestoreProduct :one
UPDATE products
SET
    deleted_at = NULL
WHERE
    product_id = $1
    AND deleted_at IS NOT NULL
  RETURNING product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
`

// Restore Trashed Product
func (q *Queries) RestoreProduct(ctx context.Context, productID int32) (*Product, error) {
	row := q.db.QueryRowContext(ctx, restoreProduct, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashProduct = `-- name: TrashProduct :one
UPDATE products
SET
    deleted_at = current_timestamp
WHERE
    product_id = $1
    AND deleted_at IS NULL
    RETURNING product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
`

// Trash Product
func (q *Queries) TrashProduct(ctx context.Context, productID int32) (*Product, error) {
	row := q.db.QueryRowContext(ctx, trashProduct, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET category_id = $2,
    name = $3,
    description = $4,
    price = $5,
    count_in_stock = $6,
    brand = $7,
    weight = $8,
    rating = $9,
    slug_product = $10,
    image_product = $11,
    barcode = $12,
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1
  AND deleted_at IS NULL
  RETURNING product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ProductID    int32           `json:"product_id"`
	CategoryID   int32           `json:"category_id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        int32           `json:"price"`
	CountInStock int32           `json:"count_in_stock"`
	Brand        sql.NullString  `json:"brand"`
	Weight       sql.NullInt32   `json:"weight"`
	Rating       sql.NullFloat64 `json:"rating"`
	SlugProduct  sql.NullString  `json:"slug_product"`
	ImageProduct sql.NullString  `json:"image_product"`
	Barcode      sql.NullString  `json:"barcode"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ProductID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.CountInStock,
		arg.Brand,
		arg.Weight,
		arg.Rating,
		arg.SlugProduct,
		arg.ImageProduct,
		arg.Barcode,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateProductCountStock = `-- name: UpdateProductCountStock :one
UPDATE products
SET count_in_stock = $2
WHERE product_id = $1
    AND deleted_at IS NULL
RETURNING product_id, merchant_id, category_id, name, description, price, count_in_stock, brand, weight, rating, slug_product, image_product, barcode, created_at, updated_at, deleted_at
`

type UpdateProductCountStockParams struct {
	ProductID    int32 `json:"product_id"`
	CountInStock int32 `json:"count_in_stock"`
}

func (q *Queries) UpdateProductCountStock(ctx context.Context, arg UpdateProductCountStockParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, updateProductCountStock, arg.ProductID, arg.CountInStock)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CountInStock,
		&i.Brand,
		&i.Weight,
		&i.Rating,
		&i.SlugProduct,
		&i.ImageProduct,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
