// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (merchant_id, cashier_id, total_price)
VALUES ($1, $2, $3)
RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	MerchantID int32 `json:"merchant_id"`
	CashierID  int32 `json:"cashier_id"`
	TotalPrice int64 `json:"total_price"`
}

// CreateOrder: Creates a new order record
// Purpose: Register a new transaction in the system
// Parameters:
//
//	$1: merchant_id - UUID of the merchant associated with the order
//	$2: cashier_id - ID of the cashier processing the order
//	$3: total_price - Numeric total amount of the order
//
// Returns: The complete created order record
// Business Logic:
//   - Automatically sets created_at timestamp
//   - Requires merchant_id, cashier_id and total_price
//   - Typically followed by order item creation
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (*Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.MerchantID, arg.CashierID, arg.TotalPrice)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentOrders = `-- name: DeleteAllPermanentOrders :exec
DELETE FROM orders
WHERE
    deleted_at IS NOT NULL
`

// DeleteAllPermanentOrders: Purges all cancelled orders
// Purpose: Clean up all soft-deleted order records
// Business Logic:
//   - Irreversible bulk deletion operation
//   - Only affects already cancelled orders
//   - Typically used during database maintenance
//   - Should be restricted to admin users
func (q *Queries) DeleteAllPermanentOrders(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentOrders)
	return err
}

const deleteOrderPermanently = `-- name: DeleteOrderPermanently :exec
DELETE FROM orders WHERE order_id = $1 AND deleted_at IS NOT NULL
`

// DeleteOrderPermanently: Hard-deletes an order
// Purpose: Completely remove order from database
// Parameters:
//
//	$1: order_id - UUID of order to delete
//
// Business Logic:
//   - Permanent deletion of already cancelled orders
//   - No return value (exec-only operation)
//   - Irreversible action - use with caution
//   - Should trigger deletion of related order_items
func (q *Queries) DeleteOrderPermanently(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrderPermanently, orderID)
	return err
}

const getMonthlyOrder = `-- name: GetMonthlyOrder :many
WITH date_range AS (
    SELECT 
        date_trunc('month', $1::timestamp) AS start_date,
        date_trunc('month', $1::timestamp) + interval '1 year' - interval '1 day' AS end_date
),
monthly_orders AS (
    SELECT
        date_trunc('month', o.created_at) AS activity_month,
        COUNT(o.order_id) AS order_count,
        SUM(o.total_price)::NUMERIC AS total_revenue,
        SUM(oi.quantity) AS total_items_sold
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND o.created_at BETWEEN (SELECT start_date FROM date_range) 
                             AND (SELECT end_date FROM date_range)
    GROUP BY
        activity_month
)
SELECT
    TO_CHAR(mo.activity_month, 'Mon') AS month,
    mo.order_count,
    mo.total_revenue,
    mo.total_items_sold
FROM
    monthly_orders mo
ORDER BY
    mo.activity_month
`

type GetMonthlyOrderRow struct {
	Month          string  `json:"month"`
	OrderCount     int64   `json:"order_count"`
	TotalRevenue   float64 `json:"total_revenue"`
	TotalItemsSold int64   `json:"total_items_sold"`
}

// GetMonthlyOrder: Retrieves monthly order summary within a 1-year period
// Purpose: Provides monthly sales performance metrics for trend and operational analysis
// Parameters:
//
//	$1: Reference date (timestamp) - determines the 12-month analysis window
//
// Returns:
//
//	month: 3-letter abbreviation of the month (e.g., 'Jan')
//	order_count: Total number of orders in the month
//	total_revenue: Sum of total price from all orders
//	total_items_sold: Total quantity of items sold in that month
//
// Business Logic:
//   - Analyzes a 12-month period starting from the month of the reference date
//   - Ignores soft-deleted records for accurate reporting
//   - Aggregates data by month for visualizations and monthly performance tracking
//   - Uses short month format for dashboard/chart compactness
//   - Sorts chronologically by month
func (q *Queries) GetMonthlyOrder(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyOrder, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyOrderRow
	for rows.Next() {
		var i GetMonthlyOrderRow
		if err := rows.Scan(
			&i.Month,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalItemsSold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyOrderByMerchant = `-- name: GetMonthlyOrderByMerchant :many
WITH date_range AS (
    SELECT 
        date_trunc('month', $1::timestamp) AS start_date,
        date_trunc('month', $1::timestamp) + interval '1 year' - interval '1 day' AS end_date
),
monthly_orders AS (
    SELECT
        date_trunc('month', o.created_at) AS activity_month,
        COUNT(o.order_id) AS order_count,
        SUM(o.total_price)::NUMERIC AS total_revenue,
        SUM(oi.quantity) AS total_items_sold
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND o.created_at BETWEEN (SELECT start_date FROM date_range) 
                             AND (SELECT end_date FROM date_range)
        AND o.merchant_id = $2
    GROUP BY
        activity_month
)
SELECT
    TO_CHAR(mo.activity_month, 'Mon') AS month,
    mo.order_count,
    mo.total_revenue,
    mo.total_items_sold
FROM
    monthly_orders mo
ORDER BY
    mo.activity_month
`

type GetMonthlyOrderByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyOrderByMerchantRow struct {
	Month          string  `json:"month"`
	OrderCount     int64   `json:"order_count"`
	TotalRevenue   float64 `json:"total_revenue"`
	TotalItemsSold int64   `json:"total_items_sold"`
}

// GetMonthlyOrderByMerchant: Retrieves monthly order summary within a 1-year period by merchant_id
// Purpose: Provides monthly sales performance metrics for trend and operational analysis
// Parameters:
//
//	$1: Reference date (timestamp) - determines the 12-month analysis window
//	$2: Merchant ID
//
// Returns:
//
//	month: 3-letter abbreviation of the month (e.g., 'Jan')
//	order_count: Total number of orders in the month
//	total_revenue: Sum of total price from all orders
//	total_items_sold: Total quantity of items sold in that month
//
// Business Logic:
//   - Analyzes a 12-month period starting from the month of the reference date
//   - Ignores soft-deleted records for accurate reporting
//   - Aggregates data by month for visualizations and monthly performance tracking
//   - Uses short month format for dashboard/chart compactness
//   - Sorts chronologically by month
func (q *Queries) GetMonthlyOrderByMerchant(ctx context.Context, arg GetMonthlyOrderByMerchantParams) ([]*GetMonthlyOrderByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyOrderByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyOrderByMerchantRow
	for rows.Next() {
		var i GetMonthlyOrderByMerchantRow
		if err := rows.Scan(
			&i.Month,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalItemsSold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalRevenue = `-- name: GetMonthlyTotalRevenue :many
WITH monthly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::TEXT AS year,
        EXTRACT(MONTH FROM o.created_at)::integer AS month,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            (o.created_at >= $1 AND o.created_at <= $2)  
            OR (o.created_at >= $3 AND o.created_at <= $4) 
        )
    GROUP BY
        EXTRACT(YEAR FROM o.created_at),
        EXTRACT(MONTH FROM o.created_at)
),
all_months AS (
    SELECT 
        EXTRACT(YEAR FROM $1)::TEXT AS year,
        EXTRACT(MONTH FROM $1)::integer AS month,
        TO_CHAR($1, 'FMMonth') AS month_name
    
    UNION
    
    SELECT 
        EXTRACT(YEAR FROM $3)::TEXT AS year,
        EXTRACT(MONTH FROM $3)::integer AS month,
        TO_CHAR($3, 'FMMonth') AS month_name
)
SELECT 
    COALESCE(am.year, EXTRACT(YEAR FROM $1)::TEXT) AS year,
    COALESCE(am.month_name, TO_CHAR($1, 'FMMonth')) AS month,
    COALESCE(mr.total_revenue, 0) AS total_revenue
FROM 
    all_months am
LEFT JOIN 
    monthly_revenue mr ON am.year = mr.year 
                      AND am.month = mr.month
ORDER BY 
    am.year DESC,
    am.month DESC
`

type GetMonthlyTotalRevenueParams struct {
	Extract     time.Time    `json:"extract"`
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
	CreatedAt_3 sql.NullTime `json:"created_at_3"`
}

type GetMonthlyTotalRevenueRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetMonthlyTotalRevenue: Retrieves monthly total revenue across two custom date ranges
// Purpose: Compare total revenue between two time periods (e.g., current month vs previous month)
// Parameters:
//
//	$1: Start date of first period
//	$2: End date of first period
//	$3: Start date of second period
//	$4: End date of second period
//
// Returns:
//
//	year: The year of the revenue data
//	month: The full month name (e.g., "January")
//	total_revenue: Total revenue (SUM of order totals) for that month (0 if no revenue)
//
// Business Logic:
//   - Compares revenue between two customizable time periods
//   - Ensures all selected months appear even if no revenue (gap filling)
//   - Includes only non-deleted orders and order items
//   - Output formatted for charting or reporting tools
func (q *Queries) GetMonthlyTotalRevenue(ctx context.Context, arg GetMonthlyTotalRevenueParams) ([]*GetMonthlyTotalRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalRevenue,
		arg.Extract,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.CreatedAt_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalRevenueRow
	for rows.Next() {
		var i GetMonthlyTotalRevenueRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalRevenueById = `-- name: GetMonthlyTotalRevenueById :many
WITH monthly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::TEXT AS year,
        EXTRACT(MONTH FROM o.created_at)::integer AS month,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            (o.created_at >= $1 AND o.created_at <= $2)  
            OR (o.created_at >= $3 AND o.created_at <= $4) 
        )
        AND o.order_id = $5
    GROUP BY
        EXTRACT(YEAR FROM o.created_at),
        EXTRACT(MONTH FROM o.created_at)
),
all_months AS (
    SELECT 
        EXTRACT(YEAR FROM $1)::TEXT AS year,
        EXTRACT(MONTH FROM $1)::integer AS month,
        TO_CHAR($1, 'FMMonth') AS month_name
    
    UNION
    
    SELECT 
        EXTRACT(YEAR FROM $3)::TEXT AS year,
        EXTRACT(MONTH FROM $3)::integer AS month,
        TO_CHAR($3, 'FMMonth') AS month_name
)
SELECT 
    COALESCE(am.year, EXTRACT(YEAR FROM $1)::TEXT) AS year,
    COALESCE(am.month_name, TO_CHAR($1, 'FMMonth')) AS month,
    COALESCE(mr.total_revenue, 0) AS total_revenue
FROM 
    all_months am
LEFT JOIN 
    monthly_revenue mr ON am.year = mr.year 
                      AND am.month = mr.month
ORDER BY 
    am.year DESC,
    am.month DESC
`

type GetMonthlyTotalRevenueByIdParams struct {
	Extract     time.Time    `json:"extract"`
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
	CreatedAt_3 sql.NullTime `json:"created_at_3"`
	OrderID     int32        `json:"order_id"`
}

type GetMonthlyTotalRevenueByIdRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetMonthlyTotalRevenueById: Retrieves monthly total revenue across two custom date ranges by order_id
// Purpose: Compare total revenue between two time periods (e.g., current month vs previous month)
// Parameters:
//
//	$1: Start date of first period
//	$2: End date of first period
//	$3: Start date of second period
//	$4: End date of second period
//	$5: Order ID
//
// Returns:
//
//	year: The year of the revenue data
//	month: The full month name (e.g., "January")
//	total_revenue: Total revenue (SUM of order totals) for that month (0 if no revenue)
//
// Business Logic:
//   - Compares revenue between two customizable time periods
//   - Ensures all selected months appear even if no revenue (gap filling)
//   - Includes only non-deleted orders and order items
//   - Output formatted for charting or reporting tools
func (q *Queries) GetMonthlyTotalRevenueById(ctx context.Context, arg GetMonthlyTotalRevenueByIdParams) ([]*GetMonthlyTotalRevenueByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalRevenueById,
		arg.Extract,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.CreatedAt_3,
		arg.OrderID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalRevenueByIdRow
	for rows.Next() {
		var i GetMonthlyTotalRevenueByIdRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalRevenueByMerchant = `-- name: GetMonthlyTotalRevenueByMerchant :many
WITH monthly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::TEXT AS year,
        EXTRACT(MONTH FROM o.created_at)::integer AS month,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            (o.created_at >= $1 AND o.created_at <= $2)  
            OR (o.created_at >= $3 AND o.created_at <= $4) 
        )
        AND o.merchant_id = $5
    GROUP BY
        EXTRACT(YEAR FROM o.created_at),
        EXTRACT(MONTH FROM o.created_at)
),
all_months AS (
    SELECT 
        EXTRACT(YEAR FROM $1)::TEXT AS year,
        EXTRACT(MONTH FROM $1)::integer AS month,
        TO_CHAR($1, 'FMMonth') AS month_name
    
    UNION
    
    SELECT 
        EXTRACT(YEAR FROM $3)::TEXT AS year,
        EXTRACT(MONTH FROM $3)::integer AS month,
        TO_CHAR($3, 'FMMonth') AS month_name
)
SELECT 
    COALESCE(am.year, EXTRACT(YEAR FROM $1)::TEXT) AS year,
    COALESCE(am.month_name, TO_CHAR($1, 'FMMonth')) AS month,
    COALESCE(mr.total_revenue, 0) AS total_revenue
FROM 
    all_months am
LEFT JOIN 
    monthly_revenue mr ON am.year = mr.year 
                      AND am.month = mr.month
ORDER BY 
    am.year DESC,
    am.month DESC
`

type GetMonthlyTotalRevenueByMerchantParams struct {
	Extract     time.Time    `json:"extract"`
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
	CreatedAt_3 sql.NullTime `json:"created_at_3"`
	MerchantID  int32        `json:"merchant_id"`
}

type GetMonthlyTotalRevenueByMerchantRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetMonthlyTotalRevenueByMerchant: Retrieves monthly total revenue across two custom date ranges by merchant_id
// Purpose: Compare total revenue between two time periods (e.g., current month vs previous month)
// Parameters:
//
//	$1: Start date of first period
//	$2: End date of first period
//	$3: Start date of second period
//	$4: End date of second period
//	$5: Order ID
//
// Returns:
//
//	year: The year of the revenue data
//	month: The full month name (e.g., "January")
//	total_revenue: Total revenue (SUM of order totals) for that month (0 if no revenue)
//
// Business Logic:
//   - Compares revenue between two customizable time periods
//   - Ensures all selected months appear even if no revenue (gap filling)
//   - Includes only non-deleted orders and order items
//   - Output formatted for charting or reporting tools
func (q *Queries) GetMonthlyTotalRevenueByMerchant(ctx context.Context, arg GetMonthlyTotalRevenueByMerchantParams) ([]*GetMonthlyTotalRevenueByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalRevenueByMerchant,
		arg.Extract,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.CreatedAt_3,
		arg.MerchantID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalRevenueByMerchantRow
	for rows.Next() {
		var i GetMonthlyTotalRevenueByMerchantRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
FROM orders
WHERE order_id = $1
  AND deleted_at IS NULL
`

// GetOrderByID: Retrieves an active order by ID
// Purpose: Fetch order details for display/processing
// Parameters:
//
//	$1: order_id - UUID of the order to retrieve
//
// Returns: Full order record if found and active
// Business Logic:
//   - Excludes soft-deleted orders
//   - Used for order viewing, receipts, and processing
//   - Typically joined with order_items in application
func (q *Queries) GetOrderByID(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getOrders = `-- name: GetOrders :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int64        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetOrders: Retrieves paginated list of active orders with search capability
// Purpose: List all active orders for management UI
// Parameters:
//
//	$1: search_term - Optional text to filter orders by ID or total price (NULL for no filter)
//	$2: limit - Maximum number of records to return (pagination limit)
//	$3: offset - Number of records to skip (pagination offset)
//
// Returns:
//
//	All order fields plus total_count of matching records
//
// Business Logic:
//   - Excludes soft-deleted orders (deleted_at IS NULL)
//   - Supports partial text matching on order_id and total_price fields (case-insensitive)
//   - Returns newest orders first (created_at DESC)
//   - Provides total_count for client-side pagination
//   - Uses window function COUNT(*) OVER() for efficient total count
func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]*GetOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersActive = `-- name: GetOrdersActive :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersActiveRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int64        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetOrdersActive: Retrieves paginated list of active orders (identical to GetOrders)
// Purpose: Maintains consistent API pattern with other active/trashed endpoints
// Parameters:
//
//	$1: search_term - Optional filter text for order ID or price
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Returns:
//
//	Active order records with total_count
//
// Business Logic:
//   - Same functionality as GetOrders
//   - Exists for consistency in API design patterns
//
// Note: Could be consolidated with GetOrders if duplicate functionality is undesired
func (q *Queries) GetOrdersActive(ctx context.Context, arg GetOrdersActiveParams) ([]*GetOrdersActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersActiveRow
	for rows.Next() {
		var i GetOrdersActiveRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByMerchant = `-- name: GetOrdersByMerchant :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE 
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
    AND ($4::UUID IS NULL OR merchant_id = $4)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersByMerchantParams struct {
	Column1 string    `json:"column_1"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
	Column4 uuid.UUID `json:"column_4"`
}

type GetOrdersByMerchantRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int64        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetOrdersByMerchant: Retrieves merchant-specific orders with pagination
// Purpose: List orders filtered by merchant ID
// Parameters:
//
//	$1: search_term - Optional text to filter orders
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//	$4: merchant_id - Optional merchant UUID to filter by (NULL for all merchants)
//
// Returns:
//
//	Order records with total_count
//
// Business Logic:
//   - Combines merchant filtering with search functionality
//   - Maintains same sorting and pagination as other order queries
//   - Useful for merchant-specific order dashboards
//   - NULL merchant_id parameter returns all merchants' orders
func (q *Queries) GetOrdersByMerchant(ctx context.Context, arg GetOrdersByMerchantParams) ([]*GetOrdersByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByMerchant,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersByMerchantRow
	for rows.Next() {
		var i GetOrdersByMerchantRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersTrashed = `-- name: GetOrdersTrashed :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersTrashedRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int64        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetOrdersTrashed: Retrieves paginated list of soft-deleted orders
// Purpose: View and manage deleted orders for potential restoration
// Parameters:
//
//	$1: search_term - Optional text to filter trashed orders
//	$2: limit - Maximum records per page
//	$3: offset - Records to skip
//
// Returns:
//
//	Trashed order records with total_count
//
// Business Logic:
//   - Only returns soft-deleted records (deleted_at IS NOT NULL)
//   - Maintains same search functionality as active order queries
//   - Preserves chronological sorting (newest first)
//   - Used in order recovery/audit interfaces
//   - Includes total_count for pagination in trash management UI
func (q *Queries) GetOrdersTrashed(ctx context.Context, arg GetOrdersTrashedParams) ([]*GetOrdersTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersTrashedRow
	for rows.Next() {
		var i GetOrdersTrashedRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyOrder = `-- name: GetYearlyOrder :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::text AS year,
        COUNT(o.order_id) AS order_count,
        SUM(o.total_price)::NUMERIC AS total_revenue,
        SUM(oi.quantity) AS total_items_sold,
        COUNT(DISTINCT o.cashier_id) AS active_cashiers,
        COUNT(DISTINCT oi.product_id) AS unique_products_sold
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND EXTRACT(YEAR FROM o.created_at) BETWEEN (EXTRACT(YEAR FROM $1::timestamp) - 4) AND EXTRACT(YEAR FROM $1::timestamp)
    GROUP BY
        EXTRACT(YEAR FROM o.created_at)
)
SELECT
    year,
    order_count,
    total_revenue,
    total_items_sold,
    active_cashiers,
    unique_products_sold
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyOrderRow struct {
	Year               string  `json:"year"`
	OrderCount         int64   `json:"order_count"`
	TotalRevenue       float64 `json:"total_revenue"`
	TotalItemsSold     int64   `json:"total_items_sold"`
	ActiveCashiers     int64   `json:"active_cashiers"`
	UniqueProductsSold int64   `json:"unique_products_sold"`
}

// GetYearlyOrder: Retrieves yearly order summary over the past 5 years
// Purpose: Enables long-term trend analysis of sales performance
// Parameters:
//
//	$1: Reference date (timestamp) - defines the 5-year analysis window
//
// Returns:
//
//	year: 4-digit year as string
//	order_count: Total number of orders in the year
//	total_revenue: Sum of total price from all orders
//	total_items_sold: Total quantity of items sold in the year
//	active_cashiers: Number of distinct cashier IDs involved in transactions
//	unique_products_sold: Number of unique products sold
//
// Business Logic:
//   - Covers a rolling 5-year window up to the reference year
//   - Filters out deleted records to ensure data consistency
//   - Useful for high-level KPI tracking, forecasting, and strategic planning
//   - Includes both volume and revenue metrics for comprehensive reporting
//   - Results sorted by year in ascending order
func (q *Queries) GetYearlyOrder(ctx context.Context, dollar_1 time.Time) ([]*GetYearlyOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyOrder, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyOrderRow
	for rows.Next() {
		var i GetYearlyOrderRow
		if err := rows.Scan(
			&i.Year,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalItemsSold,
			&i.ActiveCashiers,
			&i.UniqueProductsSold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyOrderByMerchant = `-- name: GetYearlyOrderByMerchant :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::text AS year,
        COUNT(o.order_id) AS order_count,
        SUM(o.total_price)::NUMERIC AS total_revenue,
        SUM(oi.quantity) AS total_items_sold,
        COUNT(DISTINCT o.cashier_id) AS active_cashiers,
        COUNT(DISTINCT oi.product_id) AS unique_products_sold
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND EXTRACT(YEAR FROM o.created_at) BETWEEN (EXTRACT(YEAR FROM $1::timestamp) - 4) AND EXTRACT(YEAR FROM $1::timestamp)
        AND o.merchant_id = $2
    GROUP BY
        EXTRACT(YEAR FROM o.created_at)
)
SELECT
    year,
    order_count,
    total_revenue,
    total_items_sold,
    active_cashiers,
    unique_products_sold
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyOrderByMerchantParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetYearlyOrderByMerchantRow struct {
	Year               string  `json:"year"`
	OrderCount         int64   `json:"order_count"`
	TotalRevenue       float64 `json:"total_revenue"`
	TotalItemsSold     int64   `json:"total_items_sold"`
	ActiveCashiers     int64   `json:"active_cashiers"`
	UniqueProductsSold int64   `json:"unique_products_sold"`
}

// GetYearlyOrderByMerchant: Retrieves yearly order summary over the past 5 years by merchant_id
// Purpose: Enables long-term trend analysis of sales performance
// Parameters:
//
//	$1: Reference date (timestamp) - defines the 5-year analysis window
//
// Returns:
//
//	year: 4-digit year as string
//	order_count: Total number of orders in the year
//	total_revenue: Sum of total price from all orders
//	total_items_sold: Total quantity of items sold in the year
//	active_cashiers: Number of distinct cashier IDs involved in transactions
//	unique_products_sold: Number of unique products sold
//
// Business Logic:
//   - Covers a rolling 5-year window up to the reference year
//   - Filters out deleted records to ensure data consistency
//   - Useful for high-level KPI tracking, forecasting, and strategic planning
//   - Includes both volume and revenue metrics for comprehensive reporting
//   - Results sorted by year in ascending order
func (q *Queries) GetYearlyOrderByMerchant(ctx context.Context, arg GetYearlyOrderByMerchantParams) ([]*GetYearlyOrderByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyOrderByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyOrderByMerchantRow
	for rows.Next() {
		var i GetYearlyOrderByMerchantRow
		if err := rows.Scan(
			&i.Year,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalItemsSold,
			&i.ActiveCashiers,
			&i.UniqueProductsSold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalRevenue = `-- name: GetYearlyTotalRevenue :many
WITH yearly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::integer AS year,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            EXTRACT(YEAR FROM o.created_at) = $1::integer
            OR EXTRACT(YEAR FROM o.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM o.created_at)
),
all_years AS (
    SELECT $1 AS year
    UNION
    SELECT $1 - 1 AS year
)
SELECT 
    ay.year::text AS year,
    COALESCE(yr.total_revenue, 0) AS total_revenue
FROM 
    all_years ay
LEFT JOIN 
    yearly_revenue yr ON ay.year = yr.year
ORDER BY 
    ay.year DESC
`

type GetYearlyTotalRevenueRow struct {
	Year         string `json:"year"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetYearlyTotalRevenue: Retrieves yearly total revenue for current and previous year
// Purpose: Show year-over-year revenue trends
// Parameters:
//
//	$1: The current year (integer)
//
// Returns:
//
//	year: Year (as string)
//	total_revenue: Total revenue (SUM of order totals) for the year (0 if no revenue)
//
// Business Logic:
//   - Automatically compares revenue between current and previous year
//   - Includes zero-value years for complete data visualization
//   - Filters only active/non-deleted orders and order items
func (q *Queries) GetYearlyTotalRevenue(ctx context.Context, dollar_1 int32) ([]*GetYearlyTotalRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalRevenue, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalRevenueRow
	for rows.Next() {
		var i GetYearlyTotalRevenueRow
		if err := rows.Scan(&i.Year, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalRevenueById = `-- name: GetYearlyTotalRevenueById :many
WITH yearly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::integer AS year,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            EXTRACT(YEAR FROM o.created_at) = $1::integer
            OR EXTRACT(YEAR FROM o.created_at) = $1::integer - 1
        )
        AND o.order_id =  $2
    GROUP BY
        EXTRACT(YEAR FROM o.created_at)
),
all_years AS (
    SELECT $1 AS year
    UNION
    SELECT $1 - 1 AS year
)
SELECT 
    ay.year::text AS year,
    COALESCE(yr.total_revenue, 0) AS total_revenue
FROM 
    all_years ay
LEFT JOIN 
    yearly_revenue yr ON ay.year = yr.year
ORDER BY 
    ay.year DESC
`

type GetYearlyTotalRevenueByIdParams struct {
	Column1 int32 `json:"column_1"`
	OrderID int32 `json:"order_id"`
}

type GetYearlyTotalRevenueByIdRow struct {
	Year         string `json:"year"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetYearlyTotalRevenueById: Retrieves yearly total revenue for current and previous year by order_id
// Purpose: Show year-over-year revenue trends
// Parameters:
//
//	$1: The current year (integer)
//	$2: Order ID
//
// Returns:
//
//	year: Year (as string)
//	total_revenue: Total revenue (SUM of order totals) for the year (0 if no revenue)
//
// Business Logic:
//   - Automatically compares revenue between current and previous year
//   - Includes zero-value years for complete data visualization
//   - Filters only active/non-deleted orders and order items
func (q *Queries) GetYearlyTotalRevenueById(ctx context.Context, arg GetYearlyTotalRevenueByIdParams) ([]*GetYearlyTotalRevenueByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalRevenueById, arg.Column1, arg.OrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalRevenueByIdRow
	for rows.Next() {
		var i GetYearlyTotalRevenueByIdRow
		if err := rows.Scan(&i.Year, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalRevenueByMerchant = `-- name: GetYearlyTotalRevenueByMerchant :many
WITH yearly_revenue AS (
    SELECT
        EXTRACT(YEAR FROM o.created_at)::integer AS year,
        COALESCE(SUM(o.total_price), 0)::INTEGER AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    WHERE
        o.deleted_at IS NULL
        AND oi.deleted_at IS NULL
        AND (
            EXTRACT(YEAR FROM o.created_at) = $1::integer
            OR EXTRACT(YEAR FROM o.created_at) = $1::integer - 1
        )
        AND o.merchant_id = $2
    GROUP BY
        EXTRACT(YEAR FROM o.created_at)
),
all_years AS (
    SELECT $1 AS year
    UNION
    SELECT $1 - 1 AS year
)
SELECT 
    ay.year::text AS year,
    COALESCE(yr.total_revenue, 0) AS total_revenue
FROM 
    all_years ay
LEFT JOIN 
    yearly_revenue yr ON ay.year = yr.year
ORDER BY 
    ay.year DESC
`

type GetYearlyTotalRevenueByMerchantParams struct {
	Column1    int32 `json:"column_1"`
	MerchantID int32 `json:"merchant_id"`
}

type GetYearlyTotalRevenueByMerchantRow struct {
	Year         string `json:"year"`
	TotalRevenue int32  `json:"total_revenue"`
}

// GetYearlyTotalRevenueByMerchant: Retrieves yearly total revenue for current and previous year by merchant_id
// Purpose: Show year-over-year revenue trends
// Parameters:
//
//	$1: The current year (integer)
//	$2: Order ID
//
// Returns:
//
//	year: Year (as string)
//	total_revenue: Total revenue (SUM of order totals) for the year (0 if no revenue)
//
// Business Logic:
//   - Automatically compares revenue between current and previous year
//   - Includes zero-value years for complete data visualization
//   - Filters only active/non-deleted orders and order items
func (q *Queries) GetYearlyTotalRevenueByMerchant(ctx context.Context, arg GetYearlyTotalRevenueByMerchantParams) ([]*GetYearlyTotalRevenueByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalRevenueByMerchant, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalRevenueByMerchantRow
	for rows.Next() {
		var i GetYearlyTotalRevenueByMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllOrders = `-- name: RestoreAllOrders :exec
UPDATE orders
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// RestoreAllOrders: Mass restoration of cancelled orders
// Purpose: Recover all trashed orders at once
// Business Logic:
//   - Reactivates all soft-deleted orders
//   - No parameters needed (bulk operation)
//   - Typically used during system recovery
func (q *Queries) RestoreAllOrders(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllOrders)
	return err
}

const restoreOrder = `-- name: RestoreOrder :one
UPDATE orders
SET
    deleted_at = NULL
WHERE
    order_id = $1
    AND deleted_at IS NOT NULL
  RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

// RestoreOrder: Recovers a soft-deleted order
// Purpose: Reactivate a cancelled order
// Parameters:
//
//	$1: order_id - UUID of order to restore
//
// Returns: The restored order record
// Business Logic:
//   - Nullifies deleted_at field
//   - Only works on previously cancelled orders
//   - Maintains all original order data
func (q *Queries) RestoreOrder(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, restoreOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashedOrder = `-- name: TrashedOrder :one
UPDATE orders
SET
    deleted_at = current_timestamp
WHERE
    order_id = $1
    AND deleted_at IS NULL
    RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

// TrashedOrder: Soft-deletes an order
// Purpose: Cancel/void an order without permanent deletion
// Parameters:
//
//	$1: order_id - UUID of order to cancel
//
// Returns: The soft-deleted order record
// Business Logic:
//   - Sets deleted_at to current timestamp
//   - Preserves order data for reporting
//   - Only processes active orders
//   - Can be restored via RestoreOrder
func (q *Queries) TrashedOrder(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, trashedOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET total_price = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE order_id = $1
  AND deleted_at IS NULL
  RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

type UpdateOrderParams struct {
	OrderID    int32 `json:"order_id"`
	TotalPrice int64 `json:"total_price"`
}

// UpdateOrder: Modifies order information
// Purpose: Update order details (primarily total price)
// Parameters:
//
//	$1: order_id - UUID of order to update
//	$2: total_price - New total amount
//
// Returns: Updated order record
// Business Logic:
//   - Auto-updates updated_at timestamp
//   - Only modifies active (non-deleted) orders
//   - Used when order items change
//   - Should trigger recalculation of total_price
func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (*Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrder, arg.OrderID, arg.TotalPrice)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
