// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (merchant_id, cashier_id, total_price)
VALUES ($1, $2, $3)
RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	MerchantID int32 `json:"merchant_id"`
	CashierID  int32 `json:"cashier_id"`
	TotalPrice int32 `json:"total_price"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (*Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.MerchantID, arg.CashierID, arg.TotalPrice)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentOrders = `-- name: DeleteAllPermanentOrders :exec
DELETE FROM orders
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Order Permanently
func (q *Queries) DeleteAllPermanentOrders(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentOrders)
	return err
}

const deleteOrderPermanently = `-- name: DeleteOrderPermanently :exec
DELETE FROM orders WHERE order_id = $1 AND deleted_at IS NOT NULL
`

// Delete Order Permanently
func (q *Queries) DeleteOrderPermanently(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrderPermanently, orderID)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
FROM orders
WHERE order_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetOrderByID(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getOrders = `-- name: GetOrders :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int32        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Orders with Pagination and Total Count
func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]*GetOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersActive = `-- name: GetOrdersActive :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersActiveRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int32        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Active Orders with Pagination and Total Count
func (q *Queries) GetOrdersActive(ctx context.Context, arg GetOrdersActiveParams) ([]*GetOrdersActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersActiveRow
	for rows.Next() {
		var i GetOrdersActiveRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByMerchant = `-- name: GetOrdersByMerchant :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE 
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
    AND ($4::UUID IS NULL OR merchant_id = $4)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersByMerchantParams struct {
	Column1 string    `json:"column_1"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
	Column4 uuid.UUID `json:"column_4"`
}

type GetOrdersByMerchantRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int32        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Orders with Pagination and Total Count where merchant_id
func (q *Queries) GetOrdersByMerchant(ctx context.Context, arg GetOrdersByMerchantParams) ([]*GetOrdersByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByMerchant,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersByMerchantRow
	for rows.Next() {
		var i GetOrdersByMerchantRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersTrashed = `-- name: GetOrdersTrashed :many
SELECT
    order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR total_price::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrdersTrashedRow struct {
	OrderID    int32        `json:"order_id"`
	MerchantID int32        `json:"merchant_id"`
	CashierID  int32        `json:"cashier_id"`
	TotalPrice int32        `json:"total_price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Trashed Orders with Pagination and Total Count
func (q *Queries) GetOrdersTrashed(ctx context.Context, arg GetOrdersTrashedParams) ([]*GetOrdersTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrdersTrashedRow
	for rows.Next() {
		var i GetOrdersTrashedRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.CashierID,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllOrders = `-- name: RestoreAllOrders :exec
UPDATE orders
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Order
func (q *Queries) RestoreAllOrders(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllOrders)
	return err
}

const restoreOrder = `-- name: RestoreOrder :one
UPDATE orders
SET
    deleted_at = NULL
WHERE
    order_id = $1
    AND deleted_at IS NOT NULL
  RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

// Restore Trashed Order
func (q *Queries) RestoreOrder(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, restoreOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashedOrder = `-- name: TrashedOrder :one
UPDATE orders
SET
    deleted_at = current_timestamp
WHERE
    order_id = $1
    AND deleted_at IS NULL
    RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

// Trash Order
func (q *Queries) TrashedOrder(ctx context.Context, orderID int32) (*Order, error) {
	row := q.db.QueryRowContext(ctx, trashedOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET total_price = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE order_id = $1
  AND deleted_at IS NULL
  RETURNING order_id, merchant_id, cashier_id, total_price, created_at, updated_at, deleted_at
`

type UpdateOrderParams struct {
	OrderID    int32 `json:"order_id"`
	TotalPrice int32 `json:"total_price"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (*Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrder, arg.OrderID, arg.TotalPrice)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.MerchantID,
		&i.CashierID,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
