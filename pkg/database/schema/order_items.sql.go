// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: order_items.sql

package db

import (
	"context"
	"database/sql"
)

const calculateTotalPrice = `-- name: CalculateTotalPrice :one
SELECT COALESCE(SUM(quantity * price), 0)::int AS total_price
FROM order_items
WHERE order_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CalculateTotalPrice(ctx context.Context, orderID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, calculateTotalPrice, orderID)
	var total_price int32
	err := row.Scan(&total_price)
	return total_price, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, price)
VALUES ($1, $2, $3, $4)
RETURNING order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at
`

type CreateOrderItemParams struct {
	OrderID   int32 `json:"order_id"`
	ProductID int32 `json:"product_id"`
	Quantity  int32 `json:"quantity"`
	Price     int32 `json:"price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (*OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.Price,
	)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentOrdersItem = `-- name: DeleteAllPermanentOrdersItem :exec
DELETE FROM order_items 
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Order Item Permanently
func (q *Queries) DeleteAllPermanentOrdersItem(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentOrdersItem)
	return err
}

const deleteOrderItemPermanently = `-- name: DeleteOrderItemPermanently :exec
DELETE FROM order_items WHERE order_id = $1 AND deleted_at IS NOT NULL
`

// Delete Order Item Permanently
func (q *Queries) DeleteOrderItemPermanently(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrderItemPermanently, orderID)
	return err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT
    order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM order_items
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR product_id::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrderItemsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrderItemsRow struct {
	OrderItemID int32        `json:"order_item_id"`
	OrderID     int32        `json:"order_id"`
	ProductID   int32        `json:"product_id"`
	Quantity    int32        `json:"quantity"`
	Price       int32        `json:"price"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get Order Items  with Pagination and Total Count
func (q *Queries) GetOrderItems(ctx context.Context, arg GetOrderItemsParams) ([]*GetOrderItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItems, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsActive = `-- name: GetOrderItemsActive :many
SELECT
    order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM order_items
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR product_id::TEXT ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrderItemsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrderItemsActiveRow struct {
	OrderItemID int32        `json:"order_item_id"`
	OrderID     int32        `json:"order_id"`
	ProductID   int32        `json:"product_id"`
	Quantity    int32        `json:"quantity"`
	Price       int32        `json:"price"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get Active Order Item with Pagination and Total Count
func (q *Queries) GetOrderItemsActive(ctx context.Context, arg GetOrderItemsActiveParams) ([]*GetOrderItemsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrderItemsActiveRow
	for rows.Next() {
		var i GetOrderItemsActiveRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByOrder = `-- name: GetOrderItemsByOrder :many
SELECT order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at
FROM order_items
WHERE order_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetOrderItemsByOrder(ctx context.Context, orderID int32) ([]*OrderItem, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsTrashed = `-- name: GetOrderItemsTrashed :many
SELECT
    order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM order_items
WHERE deleted_at IS NOT NULL
  AND ($1::TEXT IS NULL OR order_id::TEXT ILIKE '%' || $1 || '%' OR product_id::TEXT ILIKE '%' || $1 || '%')
ORDER BY deleted_at DESC
LIMIT $2 OFFSET $3
`

type GetOrderItemsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetOrderItemsTrashedRow struct {
	OrderItemID int32        `json:"order_item_id"`
	OrderID     int32        `json:"order_id"`
	ProductID   int32        `json:"product_id"`
	Quantity    int32        `json:"quantity"`
	Price       int32        `json:"price"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get Trashed Orders Items with Pagination and Total Count
func (q *Queries) GetOrderItemsTrashed(ctx context.Context, arg GetOrderItemsTrashedParams) ([]*GetOrderItemsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrderItemsTrashedRow
	for rows.Next() {
		var i GetOrderItemsTrashedRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllOrdersItem = `-- name: RestoreAllOrdersItem :exec
UPDATE order_items
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Order Item
func (q *Queries) RestoreAllOrdersItem(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllOrdersItem)
	return err
}

const restoreOrderItem = `-- name: RestoreOrderItem :one
UPDATE order_items
SET
    deleted_at = NULL
WHERE
    order_id = $1
    AND deleted_at IS NOT NULL
  RETURNING order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at
`

// Restore Trashed Order Item
func (q *Queries) RestoreOrderItem(ctx context.Context, orderID int32) (*OrderItem, error) {
	row := q.db.QueryRowContext(ctx, restoreOrderItem, orderID)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashOrderItem = `-- name: TrashOrderItem :one
UPDATE order_items
SET
    deleted_at = current_timestamp
WHERE
    order_id = $1
    AND deleted_at IS NULL
    RETURNING order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at
`

// Trash Order Item
func (q *Queries) TrashOrderItem(ctx context.Context, orderID int32) (*OrderItem, error) {
	row := q.db.QueryRowContext(ctx, trashOrderItem, orderID)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE order_items
SET quantity = $2,
    price = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE order_item_id = $1
  AND deleted_at IS NULL
  RETURNING order_item_id, order_id, product_id, quantity, price, created_at, updated_at, deleted_at
`

type UpdateOrderItemParams struct {
	OrderItemID int32 `json:"order_item_id"`
	Quantity    int32 `json:"quantity"`
	Price       int32 `json:"price"`
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (*OrderItem, error) {
	row := q.db.QueryRowContext(ctx, updateOrderItem, arg.OrderItemID, arg.Quantity, arg.Price)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
